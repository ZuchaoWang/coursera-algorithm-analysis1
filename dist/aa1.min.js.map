{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///aa1.min.js","webpack:///webpack/bootstrap eed69e2f1937fad6aba0","webpack:///./src/index.js","webpack:///./src/calcshortestdis.js","webpack:///./src/countinversion.js","webpack:///./src/countmincut.js","webpack:///./src/countquicksortcmp.js","webpack:///./src/countsccsize.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_countinversion","_countinversion2","_countquicksortcmp","_countquicksortcmp2","_countmincut","_countmincut2","_countsccsize","_countsccsize2","_calcshortestdis","_calcshortestdis2","countInversion","countQuickSortCmp","countMinCut","countSccSize","calcShortestDis","gAl","s","i","nn","length","disArray","Array","frontier","Map","size","minKey","minDis","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","_step$value","_slicedToArray","key","dis","err","nextKey","nextLen","has","set","Math","min","get","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","push","isArray","TypeError","sortAndCount","a","beg","end","buf","tmp","mid","floor","invLeft","invRight","invSplit","mergeAndCount","leftLen","rightLen","len","l","r","inv","useL","find","ufArr","parent","union","j","iroot","jroot","rank","adjacencyList2EdgeList","gEl","countMinCutOnce","vn","vLeft","eLeft","eSel","random","src","dst","_ref","eCross","_src","_dst","defaultRepeat","n","ceil","log","repeat","arguments","minCount","choosePivot","pivot","count","_ref2","_ref3","genChoosePivot","strategy","choosePivotFirst","choosePivotLast","choosePivotMedian","begLessThanMid","begLessThanEnd","midLessThanEnd","aCopied","slice","inverse","k","gAlInv","preprocess","order","visited","context","nFin","dfsInPreprocess","reverse","index","deeper","cur","offset","stack","_stack$pop","pop","_stack$pop2","makeLabels","labels","dfsInMakeLabels","label","_stack$pop3","_stack$pop4","getSize","counter","sizes","hasOwnProperty","sort","b"],"mappings":"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","file":"aa1.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"aa1\"] = factory();\n\telse\n\t\troot[\"aa1\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"aa1\"] = factory();\n\telse\n\t\troot[\"aa1\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _countinversion = __webpack_require__(2);\n\t\n\tvar _countinversion2 = _interopRequireDefault(_countinversion);\n\t\n\tvar _countquicksortcmp = __webpack_require__(4);\n\t\n\tvar _countquicksortcmp2 = _interopRequireDefault(_countquicksortcmp);\n\t\n\tvar _countmincut = __webpack_require__(3);\n\t\n\tvar _countmincut2 = _interopRequireDefault(_countmincut);\n\t\n\tvar _countsccsize = __webpack_require__(5);\n\t\n\tvar _countsccsize2 = _interopRequireDefault(_countsccsize);\n\t\n\tvar _calcshortestdis = __webpack_require__(1);\n\t\n\tvar _calcshortestdis2 = _interopRequireDefault(_calcshortestdis);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  countInversion: _countinversion2.default,\n\t  countQuickSortCmp: _countquicksortcmp2.default,\n\t  countMinCut: _countmincut2.default,\n\t  countSccSize: _countsccsize2.default,\n\t  calcShortestDis: _calcshortestdis2.default\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = calcShortestDis;\n\tfunction calcShortestDis(gAl, s) {\n\t  var nn = gAl.length,\n\t      disArray = new Array(nn),\n\t      frontier = new Map([[s, 0]]),\n\t      i;\n\t\n\t  for (i = 0; i < nn; i++) {\n\t    disArray[i] = null;\n\t  }\n\t\n\t  while (frontier.size > 0) {\n\t    // choose min\n\t    var minKey = null,\n\t        minDis = null;\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\t\n\t    try {\n\t      for (var _iterator = frontier[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t        var _step$value = _slicedToArray(_step.value, 2);\n\t\n\t        var key = _step$value[0];\n\t        var dis = _step$value[1];\n\t\n\t        if (minKey == null || dis < minDis) {\n\t          minKey = key;\n\t          minDis = dis;\n\t        }\n\t      }\n\t\n\t      // set dis\n\t    } catch (err) {\n\t      _didIteratorError = true;\n\t      _iteratorError = err;\n\t    } finally {\n\t      try {\n\t        if (!_iteratorNormalCompletion && _iterator.return) {\n\t          _iterator.return();\n\t        }\n\t      } finally {\n\t        if (_didIteratorError) {\n\t          throw _iteratorError;\n\t        }\n\t      }\n\t    }\n\t\n\t    disArray[minKey] = minDis;\n\t\n\t    // update frontier\n\t    frontier.delete(minKey);\n\t    for (i = 0; i < gAl[minKey].length; i++) {\n\t      var nextKey = gAl[minKey][i][0],\n\t          nextLen = gAl[minKey][i][1];\n\t\n\t      if (disArray[nextKey] == null) {\n\t        if (frontier.has(nextKey)) {\n\t          frontier.set(nextKey, Math.min(frontier.get(nextKey), disArray[minKey] + nextLen));\n\t        } else {\n\t          frontier.set(nextKey, disArray[minKey] + nextLen);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  return disArray;\n\t}\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = countInversion;\n\tfunction sortAndCount(a, beg, end, buf) {\n\t  if (end - beg <= 1) {\n\t    return 0;\n\t  } else if (end - beg === 2) {\n\t    if (a[beg] <= a[beg + 1]) {\n\t      return 0;\n\t    } else {\n\t      var tmp = a[beg];\n\t      a[beg] = a[beg + 1];\n\t      a[beg + 1] = tmp;\n\t      return 1;\n\t    }\n\t  } else {\n\t    var mid = Math.floor((beg + end) / 2),\n\t        invLeft = sortAndCount(a, beg, mid, buf),\n\t        invRight = sortAndCount(a, mid, end, buf),\n\t        invSplit = mergeAndCount(a, beg, mid, end, buf);\n\t    return invLeft + invRight + invSplit;\n\t  }\n\t}\n\t\n\tfunction mergeAndCount(a, beg, mid, end, buf) {\n\t  for (var i = beg; i < end; i++) {\n\t    buf[i] = a[i];\n\t  }\n\t  var leftLen = mid - beg,\n\t      rightLen = end - mid,\n\t      len = end - beg,\n\t      l = 0,\n\t      r = 0,\n\t      inv = 0;\n\t  for (var _i = 0; _i < len; _i++) {\n\t    var useL = r === rightLen || l !== leftLen && buf[beg + l] <= buf[mid + r];\n\t    if (useL) {\n\t      a[beg + _i] = buf[beg + l];\n\t      l++;\n\t      inv += r;\n\t    } else {\n\t      a[beg + _i] = buf[mid + r];\n\t      r++;\n\t    }\n\t  }\n\t  return inv;\n\t}\n\t\n\tfunction countInversion(a) {\n\t  var len = a.length;\n\t  if (len) {\n\t    var buf = new Array(len);\n\t    return sortAndCount(a, 0, len, buf);\n\t  } else {\n\t    return 0;\n\t  }\n\t}\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = countMinCut;\n\tfunction find(ufArr, i) {\n\t  if (ufArr[i].parent !== i) ufArr[i].parent = find(ufArr, ufArr[i].parent);\n\t\n\t  return ufArr[i].parent;\n\t}\n\t\n\tfunction union(ufArr, i, j) {\n\t  var iroot = find(ufArr, i),\n\t      jroot = find(ufArr, j);\n\t\n\t  if (ufArr[iroot].rank < ufArr[jroot].rank) ufArr[iroot].parent = jroot;else if (ufArr[iroot].rank > ufArr[jroot].rank) ufArr[jroot].parent = iroot;else {\n\t    ufArr[jroot].parent = iroot;\n\t    ufArr[iroot].rank++;\n\t  }\n\t}\n\t\n\tfunction adjacencyList2EdgeList(gAl) {\n\t  var gEl = [];\n\t  for (var i = 0; i < gAl.length; i++) {\n\t    for (var j = 0; j < gAl[i].length; j++) {\n\t      if (i < gAl[i][j]) {\n\t        gEl.push([i, gAl[i][j]]);\n\t      }\n\t    }\n\t  }\n\t  return gEl;\n\t}\n\t\n\tfunction countMinCutOnce(vn, gEl) {\n\t  var ufArr = new Array(vn);\n\t  for (var i = 0; i < vn; i++) {\n\t    ufArr[i] = {\n\t      rank: 0,\n\t      parent: i\n\t    };\n\t  }\n\t\n\t  var vLeft = vn,\n\t      eLeft = gEl.length;\n\t\n\t  while (vLeft > 2 && eLeft > 0) {\n\t    var eSel = Math.floor(Math.random() * eLeft),\n\t        src = find(ufArr, gEl[eSel][0]),\n\t        dst = find(ufArr, gEl[eSel][1]);\n\t\n\t    if (src !== dst) {\n\t      union(ufArr, src, dst);\n\t      vLeft--;\n\t    }\n\t\n\t    var _ref = [gEl[eLeft - 1], gEl[eSel]];\n\t    gEl[eSel] = _ref[0];\n\t    gEl[eLeft - 1] = _ref[1];\n\t\n\t    eLeft--;\n\t  }\n\t\n\t  var eCross = 0;\n\t  for (var _i = 0; _i < eLeft; _i++) {\n\t    var _src = find(ufArr, gEl[_i][0]),\n\t        _dst = find(ufArr, gEl[_i][1]);\n\t\n\t    if (_src !== _dst) {\n\t      eCross++;\n\t    }\n\t  }\n\t\n\t  return eCross;\n\t}\n\t\n\tfunction defaultRepeat(n) {\n\t  return Math.ceil(n * n * Math.log(n + 1));\n\t}\n\t\n\tfunction countMinCut(gAl) {\n\t  var repeat = arguments.length <= 1 || arguments[1] === undefined ? defaultRepeat(gAl.length) : arguments[1];\n\t\n\t  var vn = gAl.length,\n\t      gEl = adjacencyList2EdgeList(gAl),\n\t      minCount = countMinCutOnce(vn, gEl);\n\t\n\t  for (var i = 1; i < repeat; i++) {\n\t    minCount = Math.min(minCount, countMinCutOnce(vn, gEl));\n\t  }\n\t  return minCount;\n\t}\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = countQuickSortCmp;\n\tfunction sortAndCount(a, beg, end, choosePivot) {\n\t  if (end - beg <= 1) {\n\t    return 0;\n\t  }\n\t  var pivot = choosePivot(a, beg, end),\n\t      i = beg + 1,\n\t      j = beg + 1,\n\t      count = end - beg - 1;\n\t  var _ref = [a[pivot], a[beg]];\n\t  a[beg] = _ref[0];\n\t  a[pivot] = _ref[1];\n\t\n\t  while (j < end) {\n\t    if (a[j] < a[beg]) {\n\t      var _ref2 = [a[i], a[j]];\n\t      a[j] = _ref2[0];\n\t      a[i] = _ref2[1];\n\t\n\t      i++;\n\t    }\n\t    j++;\n\t  }\n\t  var _ref3 = [a[i - 1], a[beg]];\n\t  a[beg] = _ref3[0];\n\t  a[i - 1] = _ref3[1];\n\t\n\t  count += sortAndCount(a, beg, i - 1, choosePivot);\n\t  count += sortAndCount(a, i, end, choosePivot);\n\t  return count;\n\t}\n\t\n\tfunction genChoosePivot(strategy) {\n\t  switch (strategy) {\n\t    case 'first':\n\t      return choosePivotFirst;\n\t    case 'last':\n\t      return choosePivotLast;\n\t    case 'median':\n\t      return choosePivotMedian;\n\t    default:\n\t    // do nothing\n\t  }\n\t}\n\t\n\tfunction choosePivotFirst(a, beg, end) {\n\t  return beg;\n\t}\n\t\n\tfunction choosePivotLast(a, beg, end) {\n\t  return end - 1;\n\t}\n\t\n\tfunction choosePivotMedian(a, beg, end) {\n\t  var mid = Math.floor((beg + end - 1) / 2),\n\t      begLessThanMid = a[beg] < a[mid],\n\t      begLessThanEnd = a[beg] < a[end - 1],\n\t      midLessThanEnd = a[mid] < a[end - 1];\n\t  if (begLessThanMid + begLessThanEnd === 1) {\n\t    return beg;\n\t  }\n\t  if (!begLessThanMid + midLessThanEnd === 1) {\n\t    return mid;\n\t  }\n\t  if (!begLessThanEnd + !midLessThanEnd === 1) {\n\t    return end - 1;\n\t  }\n\t  // do nothing\n\t}\n\t\n\tfunction countQuickSortCmp(a, strategy) {\n\t  var len = a.length;\n\t  if (len) {\n\t    var aCopied = a.slice(0),\n\t        choosePivot = genChoosePivot(strategy);\n\t    return sortAndCount(aCopied, 0, len, choosePivot);\n\t  }\n\t  return 0;\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = countSccSize;\n\tfunction inverse(gAl) {\n\t  var nn = gAl.length,\n\t      gAlInv = new Array(nn),\n\t      i,\n\t      j,\n\t      k;\n\t  for (i = 0; i < nn; i++) {\n\t    gAlInv[i] = [];\n\t  }\n\t  for (i = 0; i < nn; i++) {\n\t    for (j = 0; j < gAl[i].length; j++) {\n\t      k = gAl[i][j];\n\t      gAlInv[k].push(i);\n\t    }\n\t  }\n\t  return gAlInv;\n\t}\n\t\n\tfunction preprocess(gAl) {\n\t  var gAlInv = inverse(gAl),\n\t      nn = gAlInv.length,\n\t      order = new Array(nn),\n\t      visited = new Array(nn),\n\t      i;\n\t\n\t  for (i = 0; i < nn; i++) {\n\t    visited[i] = false;\n\t  }\n\t\n\t  var context = {\n\t    gAl: gAlInv,\n\t    order: order,\n\t    visited: visited,\n\t    nFin: 0\n\t  };\n\t\n\t  for (i = 0; i < nn; i++) {\n\t    if (context.visited[i] === false) {\n\t      dfsInPreprocess(context, i);\n\t    }\n\t  }\n\t\n\t  return context.order.reverse();\n\t}\n\t\n\tfunction dfsInPreprocess(context, index) {\n\t  var cur = index,\n\t      offset = 0,\n\t      stack = [],\n\t      deeper,\n\t      next;\n\t  context.visited[cur] = true; // pre op\n\t  for (;;) {\n\t    deeper = false;\n\t    while (offset < context.gAl[cur].length) {\n\t      // recurse\n\t      next = context.gAl[cur][offset]; // recurse\n\t      if (context.visited[next] === false) {\n\t        // recurse\n\t        context.visited[next] = true; // pre op\n\t        stack.push([cur, offset + 1]);\n\t        deeper = true;\n\t        cur = next;\n\t        offset = 0;\n\t        break;\n\t      } else {\n\t        offset++;\n\t      }\n\t    }\n\t\n\t    if (deeper === false) {\n\t      context.order[context.nFin] = cur; // post op\n\t      context.nFin++; // post op\n\t      if (stack.length) {\n\t        var _stack$pop = stack.pop();\n\t\n\t        var _stack$pop2 = _slicedToArray(_stack$pop, 2);\n\t\n\t        cur = _stack$pop2[0];\n\t        offset = _stack$pop2[1];\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction makeLabels(gAl, order) {\n\t  var nn = gAl.length,\n\t      visited = new Array(nn),\n\t      i,\n\t      j;\n\t\n\t  for (i = 0; i < nn; i++) {\n\t    visited[i] = false;\n\t  }\n\t\n\t  var context = {\n\t    gAl: gAl,\n\t    order: order,\n\t    visited: visited,\n\t    labels: new Array(nn)\n\t  };\n\t\n\t  for (i = 0; i < nn; i++) {\n\t    j = context.order[i];\n\t    if (context.visited[j] === false) {\n\t      dfsInMakeLabels(context, j, j);\n\t    }\n\t  }\n\t\n\t  return context.labels;\n\t}\n\t\n\tfunction dfsInMakeLabels(context, index, label) {\n\t  var cur = index,\n\t      offset = 0,\n\t      stack = [],\n\t      deeper,\n\t      next;\n\t\n\t  context.visited[cur] = true;\n\t  context.labels[cur] = label;\n\t  for (;;) {\n\t    deeper = false;\n\t    while (offset < context.gAl[cur].length) {\n\t      next = context.gAl[cur][offset];\n\t      if (context.visited[next] === false) {\n\t        stack.push([cur, offset + 1]);\n\t        deeper = true;\n\t        context.visited[next] = true;\n\t        context.labels[next] = label;\n\t        cur = next;\n\t        offset = 0;\n\t        break;\n\t      } else {\n\t        offset++;\n\t      }\n\t    }\n\t\n\t    if (deeper === false) {\n\t      if (stack.length) {\n\t        var _stack$pop3 = stack.pop();\n\t\n\t        var _stack$pop4 = _slicedToArray(_stack$pop3, 2);\n\t\n\t        cur = _stack$pop4[0];\n\t        offset = _stack$pop4[1];\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction getSize(labels) {\n\t  var nn = labels.length,\n\t      counter = {},\n\t      i,\n\t      label;\n\t  for (i = 0; i < nn; i++) {\n\t    label = labels[i];\n\t    counter[label] = counter[label] ? counter[label] + 1 : 1;\n\t  }\n\t\n\t  var sizes = [];\n\t  for (label in counter) {\n\t    if ({}.hasOwnProperty.call(counter, label)) {\n\t      sizes.push(counter[label]);\n\t    }\n\t  }\n\t\n\t  sizes = sizes.sort(function (a, b) {\n\t    return b - a;\n\t  });\n\t  return sizes;\n\t}\n\t\n\tfunction countSccSize(gAl) {\n\t  var order = preprocess(gAl),\n\t      labels = makeLabels(gAl, order),\n\t      sizes = getSize(labels);\n\t  return sizes;\n\t}\n\tmodule.exports = exports[\"default\"];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** aa1.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap eed69e2f1937fad6aba0\n **/","import countInversion from './countinversion';\nimport countQuickSortCmp from './countquicksortcmp';\nimport countMinCut from './countmincut';\nimport countSccSize from './countsccsize';\nimport calcShortestDis from './calcshortestdis';\n\nexport default {\n  countInversion: countInversion,\n  countQuickSortCmp: countQuickSortCmp,\n  countMinCut: countMinCut,\n  countSccSize: countSccSize,\n  calcShortestDis: calcShortestDis\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","export default function calcShortestDis(gAl, s) {\n  var nn = gAl.length,\n    disArray = new Array(nn),\n    frontier = new Map([\n      [s, 0]\n    ]),\n    i;\n\n  for (i = 0; i < nn; i++) {\n    disArray[i] = null;\n  }\n\n  while (frontier.size > 0) {\n    // choose min\n    var minKey = null,\n      minDis = null;\n    for (var [key, dis] of frontier) {\n      if (minKey == null || dis < minDis) {\n        minKey = key;\n        minDis = dis;\n      }\n    }\n\n    // set dis\n    disArray[minKey] = minDis;\n\n    // update frontier\n    frontier.delete(minKey);\n    for (i = 0; i < gAl[minKey].length; i++) {\n      var nextKey = gAl[minKey][i][0],\n        nextLen = gAl[minKey][i][1];\n\n      if (disArray[nextKey] == null) {\n        if (frontier.has(nextKey)) {\n          frontier.set(nextKey, Math.min(frontier.get(nextKey), disArray[minKey] + nextLen));\n        } else {\n          frontier.set(nextKey, disArray[minKey] + nextLen);\n        }\n      }\n    }\n  }\n\n  return disArray;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/calcshortestdis.js\n **/","function sortAndCount(a, beg, end, buf) {\n  if (end - beg <= 1) {\n    return 0;\n  } else if (end - beg === 2) {\n    if (a[beg] <= a[beg + 1]) {\n      return 0;\n    } else {\n      let tmp = a[beg];\n      a[beg] = a[beg + 1];\n      a[beg + 1] = tmp;\n      return 1;\n    }\n  } else {\n    let mid = Math.floor((beg + end) / 2),\n      invLeft = sortAndCount(a, beg, mid, buf),\n      invRight = sortAndCount(a, mid, end, buf),\n      invSplit = mergeAndCount(a, beg, mid, end, buf);\n    return invLeft + invRight + invSplit;\n  }\n}\n\nfunction mergeAndCount(a, beg, mid, end, buf) {\n  for (let i = beg; i < end; i++) {\n    buf[i] = a[i];\n  }\n  let leftLen = mid - beg,\n    rightLen = end - mid,\n    len = end - beg,\n    l = 0,\n    r = 0,\n    inv = 0;\n  for (let i = 0; i < len; i++) {\n    let useL = (r === rightLen) || (l !== leftLen && buf[beg + l] <= buf[mid + r]);\n    if (useL) {\n      a[beg + i] = buf[beg + l];\n      l++;\n      inv += r;\n    } else {\n      a[beg + i] = buf[mid + r];\n      r++;\n    }\n  }\n  return inv;\n}\n\nexport default function countInversion(a) {\n  let len = a.length;\n  if (len) {\n    let buf = new Array(len);\n    return sortAndCount(a, 0, len, buf);\n  } else {\n    return 0;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/countinversion.js\n **/","function find(ufArr, i) {\n  if (ufArr[i].parent !== i)\n    ufArr[i].parent = find(ufArr, ufArr[i].parent);\n\n  return ufArr[i].parent;\n}\n\nfunction union(ufArr, i, j) {\n  let iroot = find(ufArr, i),\n    jroot = find(ufArr, j);\n\n  if (ufArr[iroot].rank < ufArr[jroot].rank)\n    ufArr[iroot].parent = jroot;\n  else if (ufArr[iroot].rank > ufArr[jroot].rank)\n    ufArr[jroot].parent = iroot;\n\n  else {\n    ufArr[jroot].parent = iroot;\n    ufArr[iroot].rank++;\n  }\n}\n\nfunction adjacencyList2EdgeList(gAl) {\n  let gEl = [];\n  for (let i = 0; i < gAl.length; i++) {\n    for (let j = 0; j < gAl[i].length; j++) {\n      if (i < gAl[i][j]) {\n        gEl.push([i, gAl[i][j]]);\n      }\n    }\n  }\n  return gEl;\n}\n\nfunction countMinCutOnce(vn, gEl) {\n  let ufArr = new Array(vn);\n  for (let i = 0; i < vn; i++) {\n    ufArr[i] = {\n      rank: 0,\n      parent: i\n    };\n  }\n\n  let vLeft = vn,\n    eLeft = gEl.length;\n\n  while (vLeft > 2 && eLeft > 0) {\n    let eSel = Math.floor(Math.random() * eLeft),\n      src = find(ufArr, gEl[eSel][0]),\n      dst = find(ufArr, gEl[eSel][1]);\n\n    if (src !== dst) {\n      union(ufArr, src, dst);\n      vLeft--;\n    }\n\n    [gEl[eSel], gEl[eLeft - 1]] = [gEl[eLeft - 1], gEl[eSel]];\n    eLeft--;\n  }\n\n  let eCross = 0;\n  for (let i = 0; i < eLeft; i++) {\n    let src = find(ufArr, gEl[i][0]),\n      dst = find(ufArr, gEl[i][1]);\n\n    if (src !== dst) {\n      eCross++;\n    }\n  }\n\n  return eCross;\n}\n\nfunction defaultRepeat(n) {\n  return Math.ceil(n * n * Math.log(n + 1));\n}\n\nexport default function countMinCut(gAl, repeat = defaultRepeat(gAl.length)) {\n  let vn = gAl.length,\n    gEl = adjacencyList2EdgeList(gAl),\n    minCount = countMinCutOnce(vn, gEl);\n\n  for (let i = 1; i < repeat; i++) {\n    minCount = Math.min(minCount, countMinCutOnce(vn, gEl));\n  }\n  return minCount;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/countmincut.js\n **/","function sortAndCount(a, beg, end, choosePivot) {\n  if (end - beg <= 1) {\n    return 0;\n  }\n  let pivot = choosePivot(a, beg, end),\n    i = beg + 1,\n    j = beg + 1,\n    count = end - beg - 1;\n  [a[beg], a[pivot]] = [a[pivot], a[beg]];\n  while (j < end) {\n    if (a[j] < a[beg]) {\n      [a[j], a[i]] = [a[i], a[j]];\n      i++;\n    }\n    j++;\n  }\n  [a[beg], a[i - 1]] = [a[i - 1], a[beg]];\n  count += sortAndCount(a, beg, i - 1, choosePivot);\n  count += sortAndCount(a, i, end, choosePivot);\n  return count;\n}\n\nfunction genChoosePivot(strategy) {\n  switch (strategy) {\n    case 'first':\n      return choosePivotFirst;\n    case 'last':\n      return choosePivotLast;\n    case 'median':\n      return choosePivotMedian;\n    default:\n      // do nothing\n  }\n}\n\nfunction choosePivotFirst(a, beg, end) {\n  return beg;\n}\n\nfunction choosePivotLast(a, beg, end) {\n  return end - 1;\n}\n\nfunction choosePivotMedian(a, beg, end) {\n  let mid = Math.floor((beg + end - 1) / 2),\n    begLessThanMid = (a[beg] < a[mid]),\n    begLessThanEnd = (a[beg] < a[end - 1]),\n    midLessThanEnd = (a[mid] < a[end - 1]);\n  if (begLessThanMid + begLessThanEnd === 1) {\n    return beg;\n  }\n  if (!begLessThanMid + midLessThanEnd === 1) {\n    return mid;\n  }\n  if (!begLessThanEnd + !midLessThanEnd === 1) {\n    return end - 1;\n  }\n  // do nothing\n}\n\nexport default function countQuickSortCmp(a, strategy) {\n  let len = a.length;\n  if (len) {\n    let aCopied = a.slice(0),\n      choosePivot = genChoosePivot(strategy);\n    return sortAndCount(aCopied, 0, len, choosePivot);\n  }\n  return 0;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/countquicksortcmp.js\n **/","function inverse(gAl) {\n  var nn = gAl.length,\n    gAlInv = new Array(nn),\n    i, j, k;\n  for (i = 0; i < nn; i++) {\n    gAlInv[i] = [];\n  }\n  for (i = 0; i < nn; i++) {\n    for (j = 0; j < gAl[i].length; j++) {\n      k = gAl[i][j];\n      gAlInv[k].push(i);\n    }\n  }\n  return gAlInv;\n}\n\nfunction preprocess(gAl) {\n  var gAlInv = inverse(gAl),\n    nn = gAlInv.length,\n    order = new Array(nn),\n    visited = new Array(nn),\n    i;\n\n  for (i = 0; i < nn; i++) {\n    visited[i] = false;\n  }\n\n  var context = {\n    gAl: gAlInv,\n    order: order,\n    visited: visited,\n    nFin: 0\n  };\n\n  for (i = 0; i < nn; i++) {\n    if (context.visited[i] === false) {\n      dfsInPreprocess(context, i);\n    }\n  }\n\n  return context.order.reverse();\n}\n\nfunction dfsInPreprocess(context, index) {\n  var cur = index,\n    offset = 0,\n    stack = [],\n    deeper,\n    next;\n  context.visited[cur] = true; // pre op\n  for (;;) {\n    deeper = false;\n    while (offset < context.gAl[cur].length) { // recurse\n      next = context.gAl[cur][offset]; // recurse\n      if (context.visited[next] === false) { // recurse\n        context.visited[next] = true; // pre op\n        stack.push([cur, offset + 1]);\n        deeper = true;\n        cur = next;\n        offset = 0;\n        break;\n      } else {\n        offset++;\n      }\n    }\n\n    if (deeper === false) {\n      context.order[context.nFin] = cur; // post op\n      context.nFin++; // post op\n      if (stack.length) {\n        [cur, offset] = stack.pop();\n      } else {\n        break;\n      }\n    }\n  }\n}\n\nfunction makeLabels(gAl, order) {\n  var nn = gAl.length,\n    visited = new Array(nn),\n    i, j;\n\n  for (i = 0; i < nn; i++) {\n    visited[i] = false;\n  }\n\n  var context = {\n    gAl: gAl,\n    order: order,\n    visited: visited,\n    labels: new Array(nn)\n  };\n\n  for (i = 0; i < nn; i++) {\n    j = context.order[i];\n    if (context.visited[j] === false) {\n      dfsInMakeLabels(context, j, j);\n    }\n  }\n\n  return context.labels;\n}\n\nfunction dfsInMakeLabels(context, index, label) {\n  var cur = index,\n    offset = 0,\n    stack = [],\n    deeper,\n    next;\n\n  context.visited[cur] = true;\n  context.labels[cur] = label;\n  for (;;) {\n    deeper = false;\n    while (offset < context.gAl[cur].length) {\n      next = context.gAl[cur][offset];\n      if (context.visited[next] === false) {\n        stack.push([cur, offset + 1]);\n        deeper = true;\n        context.visited[next] = true;\n        context.labels[next] = label;\n        cur = next;\n        offset = 0;\n        break;\n      } else {\n        offset++;\n      }\n    }\n\n    if (deeper === false) {\n      if (stack.length) {\n        [cur, offset] = stack.pop();\n      } else {\n        break;\n      }\n    }\n  }\n}\n\nfunction getSize(labels) {\n  var nn = labels.length,\n    counter = {},\n    i, label;\n  for (i = 0; i < nn; i++) {\n    label = labels[i];\n    counter[label] = counter[label] ? counter[label] + 1 : 1;\n  }\n\n  var sizes = [];\n  for (label in counter) {\n    if ({}.hasOwnProperty.call(counter, label)) {\n      sizes.push(counter[label]);\n    }\n  }\n\n  sizes = sizes.sort((a, b) => b - a);\n  return sizes;\n}\n\nexport default function countSccSize(gAl) {\n  var order = preprocess(gAl),\n    labels = makeLabels(gAl, order),\n    sizes = getSize(labels);\n  return sizes;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/countsccsize.js\n **/"],"sourceRoot":""}